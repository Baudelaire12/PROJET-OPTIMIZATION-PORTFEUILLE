"""
Application Streamlit pour l'optimisation de portefeuille.
"""
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
import sys
import os

# Ajouter le r√©pertoire parent au chemin pour pouvoir importer les modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from simple_portfolio import (
    calculate_returns,
    calculate_portfolio_metrics,
    optimize_portfolio
)

# Configuration de la page (comment√© car maintenant appel√© dans streamlit_app.py)
# st.set_page_config(
#     page_title="Optimisation de Portefeuille",
#     page_icon="üìà",
#     layout="wide"
# )

# Titre et description
st.title("üìä Optimisation de Portefeuille d'Investissement")
st.markdown("""
Cette application vous permet d'optimiser votre portefeuille d'investissement en utilisant la th√©orie moderne du portefeuille (MPT) et des mod√®les d'apprentissage automatique.
""")

# Afficher des informations sur les donn√©es
with st.expander("‚ÑπÔ∏è Informations sur les donn√©es"):
    st.markdown("""
    ### Source des donn√©es
    Les donn√©es utilis√©es dans cette application sont r√©cup√©r√©es via Yahoo Finance. Elles incluent les prix historiques des actions et sont utilis√©es pour calculer les rendements journaliers.

    ### Pr√©traitement
    Les donn√©es brutes sont pr√©trait√©es pour :
    - Calculer les rendements journaliers
    - Supprimer les valeurs aberrantes
    - G√©rer les valeurs manquantes

    ### Collecte de donn√©es r√©elles
    Vous pouvez collecter des donn√©es r√©elles directement depuis cette application :
    1. Utilisez le panneau "Collecte de donn√©es" dans la barre lat√©rale
    2. S√©lectionnez les actifs qui vous int√©ressent
    3. Cliquez sur "Collecter les donn√©es"

    Les donn√©es seront automatiquement mises √† jour et utilis√©es pour l'optimisation du portefeuille.
    """)

# Sidebar pour les param√®tres
st.sidebar.header("Param√®tres")

# Chargement des donn√©es
@st.cache_data(show_spinner=False)
def load_data():
    try:
        # Essayer de charger les donn√©es r√©elles depuis stock_data.csv (collect√©es par streamlit_app.py)
        try:
            # Afficher un message de chargement
            with st.spinner("Chargement des donn√©es r√©elles..."):
                stock_data = pd.read_csv('data/raw/stock_data.csv')
                if 'Date' in stock_data.columns and 'Ticker' in stock_data.columns and 'Close' in stock_data.columns:
                    # Cr√©er un dictionnaire pour stocker les s√©ries de prix par ticker
                    prices_dict = {}

                    # Convertir la colonne Date en datetime
                    stock_data['Date'] = pd.to_datetime(stock_data['Date'], utc=True)

                    # Parcourir les tickers uniques
                    for ticker in stock_data['Ticker'].unique():
                        # Filtrer les donn√©es pour ce ticker
                        ticker_data = stock_data[stock_data['Ticker'] == ticker]
                        # Cr√©er une s√©rie avec Date comme index et Close comme valeurs
                        prices_dict[ticker] = pd.Series(ticker_data['Close'].values, index=ticker_data['Date'])

                    # Cr√©er un DataFrame √† partir du dictionnaire
                    prices = pd.DataFrame(prices_dict)

                    # Charger les rendements calcul√©s
                    returns = pd.read_csv('data/processed/returns.csv', index_col=0, parse_dates=True)

                    st.success("Donn√©es r√©elles charg√©es avec succ√®s!")
                    return prices, returns
        except Exception as e:
            st.warning(f"Erreur lors du chargement des donn√©es r√©elles: {e}")
            st.exception(e)

        # Si les donn√©es r√©elles ne sont pas disponibles, essayer de charger les donn√©es simul√©es
        with st.spinner("Chargement des donn√©es simul√©es..."):
            prices = pd.read_csv('data/raw/stock_prices.csv', index_col=0, parse_dates=True)
            returns = pd.read_csv('data/processed/returns.csv', index_col=0, parse_dates=True)
            st.info("Utilisation de donn√©es simul√©es (les donn√©es r√©elles n'ont pas pu √™tre charg√©es).")
            return prices, returns
    except FileNotFoundError:
        st.error("Donn√©es non trouv√©es. Veuillez d'abord ex√©cuter le script de collecte de donn√©es.")
        return None, None

prices, returns = load_data()

# S√©lection des actifs
# Utiliser les colonnes disponibles dans le DataFrame returns
if returns is not None:
    available_tickers = list(returns.columns)
    default_tickers = available_tickers
    selected_tickers = st.sidebar.multiselect(
        "S√©lectionner les actifs",
        options=available_tickers,
        default=available_tickers[:5] if len(available_tickers) >= 5 else available_tickers
    )

    # Param√®tres d'optimisation
    st.sidebar.subheader("Param√®tres d'optimisation")
    risk_free_rate = st.sidebar.slider("Taux sans risque (%)", 0.0, 5.0, 1.0) / 100
    n_portfolios = st.sidebar.slider("Nombre de portefeuilles √† simuler", 1000, 10000, 5000)
else:
    st.error("Impossible de charger les donn√©es. Veuillez ex√©cuter le script de collecte de donn√©es.")
    st.stop()

if prices is not None and returns is not None:
    # Filtrer les donn√©es pour les actifs s√©lectionn√©s
    if selected_tickers:
        returns_filtered = returns[selected_tickers]
    else:
        st.warning("Veuillez s√©lectionner au moins un actif.")
        returns_filtered = returns[default_tickers[:5]]

    # Calculer les m√©triques du portefeuille
    expected_returns, cov_matrix = calculate_portfolio_metrics(returns_filtered)

    # Optimisation du portefeuille
    with st.spinner("Optimisation du portefeuille en cours..."):
        frontier, optimal_weights = optimize_portfolio(expected_returns, cov_matrix, n_portfolios)

    # Afficher les r√©sultats dans deux colonnes
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("Fronti√®re Efficiente")

        # Cr√©er un graphique interactif avec Plotly
        fig = px.scatter(
            frontier, x='Volatility', y='Return',
            color='Sharpe', color_continuous_scale='viridis',
            title='Fronti√®re Efficiente',
            labels={'Volatility': 'Volatilit√© (Risque)', 'Return': 'Rendement Attendu', 'Sharpe': 'Ratio de Sharpe'}
        )

        # Ajouter le portefeuille optimal
        max_sharpe_idx = frontier['Sharpe'].idxmax()
        fig.add_trace(go.Scatter(
            x=[frontier.loc[max_sharpe_idx, 'Volatility']],
            y=[frontier.loc[max_sharpe_idx, 'Return']],
            mode='markers',
            marker=dict(size=15, color='red'),
            name='Portefeuille Optimal'
        ))

        # Ajouter la ligne du taux sans risque
        max_vol = frontier['Volatility'].max()
        max_ret = frontier.loc[max_sharpe_idx, 'Return']
        fig.add_trace(go.Scatter(
            x=[0, max_vol * 1.2],
            y=[risk_free_rate, risk_free_rate + (max_ret - risk_free_rate) * 1.2],
            mode='lines',
            line=dict(color='red', dash='dash'),
            name='Ligne du March√© des Capitaux'
        ))

        st.plotly_chart(fig, use_container_width=True)

    with col2:
        st.subheader("Allocation du Portefeuille Optimal")

        # Cr√©er un DataFrame pour l'allocation
        allocation = pd.DataFrame({
            'Actif': returns_filtered.columns,
            'Poids': optimal_weights
        })
        allocation = allocation.sort_values('Poids', ascending=False)

        # Cr√©er un graphique interactif avec Plotly
        fig = px.bar(
            allocation, x='Actif', y='Poids',
            title='Allocation du Portefeuille Optimal',
            labels={'Actif': 'Actif', 'Poids': 'Poids dans le Portefeuille'},
            color='Poids', color_continuous_scale='viridis'
        )

        st.plotly_chart(fig, use_container_width=True)

    # Afficher les m√©triques du portefeuille optimal
    st.subheader("M√©triques du Portefeuille Optimal")

    # Calculer les m√©triques
    optimal_return = frontier.loc[max_sharpe_idx, 'Return']
    optimal_volatility = frontier.loc[max_sharpe_idx, 'Volatility']
    optimal_sharpe = frontier.loc[max_sharpe_idx, 'Sharpe']

    # Afficher les m√©triques dans trois colonnes
    metric_col1, metric_col2, metric_col3 = st.columns(3)

    with metric_col1:
        st.metric(
            label="Rendement Annuel Attendu",
            value=f"{optimal_return:.2%}"
        )

    with metric_col2:
        st.metric(
            label="Volatilit√© Annuelle",
            value=f"{optimal_volatility:.2%}"
        )

    with metric_col3:
        st.metric(
            label="Ratio de Sharpe",
            value=f"{optimal_sharpe:.2f}"
        )

    # Afficher le tableau des poids
    st.subheader("Poids du Portefeuille Optimal")

    # Formater les poids en pourcentage
    allocation['Poids (%)'] = allocation['Poids'] * 100
    st.dataframe(allocation[['Actif', 'Poids (%)']], use_container_width=True)

    # Analyse des rendements historiques
    st.subheader("Analyse des Rendements Historiques")

    # Convertir l'index en datetime si ce n'est pas d√©j√† fait
    if not isinstance(returns.index, pd.DatetimeIndex):
        returns.index = pd.to_datetime(returns.index, utc=True)

    # Convertir en UTC pour √©viter les probl√®mes de fuseau horaire
    if returns.index.tz is not None:
        returns.index = returns.index.tz_convert('UTC').tz_localize(None)

    # Extraire les dates min et max
    min_date = returns.index.min()
    max_date = returns.index.max()

    # Convertir en date (pas datetime)
    if hasattr(min_date, 'date'):
        min_date = min_date.date()
        max_date = max_date.date()

    # S√©lectionner la p√©riode
    date_range = st.slider(
        "S√©lectionner la p√©riode",
        min_value=min_date,
        max_value=max_date,
        value=(min_date, max_date)
    )

    # Convertir les dates s√©lectionn√©es en datetime pour le filtrage
    start_date = pd.Timestamp(date_range[0])
    end_date = pd.Timestamp(date_range[1])

    # Filtrer les donn√©es par p√©riode
    mask = (returns.index >= start_date) & (returns.index <= end_date)
    returns_period = returns.loc[mask]

    # Calculer les rendements cumul√©s
    cumulative_returns = (1 + returns_period[selected_tickers]).cumprod() - 1

    # Cr√©er un graphique interactif avec Plotly
    fig = px.line(
        cumulative_returns, x=cumulative_returns.index, y=cumulative_returns.columns,
        title='Rendements Cumul√©s',
        labels={'value': 'Rendement Cumul√©', 'variable': 'Actif'}
    )

    st.plotly_chart(fig, use_container_width=True)

    # T√©l√©chargement des r√©sultats
    st.subheader("T√©l√©charger les R√©sultats")

    # Cr√©er un DataFrame pour les r√©sultats
    results = pd.DataFrame({
        'Actif': allocation['Actif'],
        'Poids (%)': allocation['Poids (%)'],
        'Rendement Attendu (%)': [expected_returns[ticker] * 100 for ticker in allocation['Actif']],
        'Volatilit√© (%)': [np.sqrt(cov_matrix.loc[ticker, ticker]) * 100 for ticker in allocation['Actif']]
    })

    # Convertir en CSV pour le t√©l√©chargement
    csv = results.to_csv(index=False)
    st.download_button(
        label="T√©l√©charger les r√©sultats (CSV)",
        data=csv,
        file_name="portfolio_optimization_results.csv",
        mime="text/csv"
    )

else:
    st.error("Impossible de charger ou de g√©n√©rer les donn√©es. Veuillez v√©rifier les permissions d'√©criture dans le r√©pertoire 'data'.")
